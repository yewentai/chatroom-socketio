Project file structure for './':
├── dist
│   ├── controllers
│   │   └── chatController.js
│   ├── middleware
│   │   └── auth.js
│   ├── models
│   │   └── Message.js
│   ├── routes
│   │   └── chat.js
│   ├── server.js
│   ├── socket
│   │   └── socketHandlers.js
│   └── types
│       └── index.js
├── package.json
├── src
│   ├── controllers
│   │   └── chatController.ts
│   ├── middleware
│   │   └── auth.ts
│   ├── models
│   │   └── Message.ts
│   ├── routes
│   │   └── chat.ts
│   ├── server.ts
│   ├── socket
│   │   └── socketHandlers.ts
│   └── types
│       └── index.ts
└── tsconfig.json

===== ./package.json =====
{
  "name": "chatroom-socketio",
  "version": "1.0.0",
  "description": "A real-time chat room application using React, Tailwind CSS, Node.js, Express.js, and Socket.IO.",
  "main": "src/server.ts",
  "scripts": {
    "start": "node dist/server.js",
    "dev": "ts-node src/server.ts",
    "build": "tsc",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "mongoose": "^8.15.1",
    "socket.io": "^4.7.5"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.0.0",
    "@types/node": "^20.0.0",
    "eslint": "^9.0.0",
    "jest": "^29.0.0",
    "ts-node": "^10.9.0",
    "typescript": "^5.0.0"
  },
  "author": "Joseph Yep",
  "license": "MIT"
}


===== ./tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES6",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "typeRoots": [
      "./node_modules/@types"
    ]
  },
  "include": [
    "src/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "**/*.spec.ts"
  ]
}

===== ./dist/server.js =====
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const socket_io_1 = require("socket.io");
const chat_1 = __importDefault(require("./routes/chat"));
const socketHandlers_1 = require("./socket/socketHandlers");
const app = (0, express_1.default)();
const server = http_1.default.createServer(app);
const io = new socket_io_1.Server(server);
// Middleware
app.use(express_1.default.json());
app.use('/api/chat', chat_1.default);
// Socket.IO setup
(0, socketHandlers_1.setupSocketHandlers)(io);
const PORT = process.env.PORT || 5001;
server.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});


===== ./dist/middleware/auth.js =====
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const authMiddleware = (req, res, next) => {
    const token = req.headers['authorization'];
    if (!token) {
        return res.status(401).json({ message: 'Unauthorized' });
    }
    // Here you would typically verify the token and extract user information
    // For example, using a library like jsonwebtoken:
    // jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    //     if (err) {
    //         return res.status(403).json({ message: 'Forbidden' });
    //     }
    //     req.user = user;
    //     next();
    // });
    // For now, we'll just call next() to proceed
    next();
};
exports.default = authMiddleware;


===== ./dist/types/index.js =====
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


===== ./dist/models/Message.js =====
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const mongoose_1 = require("mongoose");
const messageSchema = new mongoose_1.Schema({
    username: {
        type: String,
        required: true,
    },
    content: {
        type: String,
        required: true,
    },
    timestamp: {
        type: Date,
        default: Date.now,
    },
});
exports.Message = (0, mongoose_1.model)('Message', messageSchema);


===== ./dist/controllers/chatController.js =====
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendMessage = exports.getMessages = void 0;
const Message_1 = require("../models/Message");
const getMessages = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const messages = yield Message_1.Message.find().sort({ createdAt: -1 });
        res.status(200).json(messages);
    }
    catch (error) {
        res.status(500).json({ message: 'Error retrieving messages' });
    }
});
exports.getMessages = getMessages;
const sendMessage = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { username, content } = req.body;
    const newMessage = new Message_1.Message({
        username,
        content,
        createdAt: new Date(),
    });
    try {
        const savedMessage = yield newMessage.save();
        res.status(201).json(savedMessage);
    }
    catch (error) {
        res.status(500).json({ message: 'Error sending message' });
    }
});
exports.sendMessage = sendMessage;


===== ./dist/routes/chat.js =====
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const chatController_1 = require("../controllers/chatController");
const router = (0, express_1.Router)();
// Route to get chat messages
router.get('/messages', chatController_1.getMessages);
// Route to send a new chat message
router.post('/messages', chatController_1.sendMessage);
exports.default = router;


===== ./dist/socket/socketHandlers.js =====
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupSocketHandlers = void 0;
const Message_1 = require("../models/Message");
const setupSocketHandlers = (io) => {
    io.on("connection", (socket) => {
        console.log("A user connected:", socket.id);
        socket.on("joinRoom", (room) => {
            socket.join(room);
            console.log(`User ${socket.id} joined room: ${room}`);
        });
        socket.on("sendMessage", (messageData) => __awaiter(void 0, void 0, void 0, function* () {
            const message = new Message_1.Message(messageData);
            yield message.save();
            io.to(messageData.room).emit("message", message);
        }));
        socket.on("disconnect", () => {
            console.log("User disconnected:", socket.id);
        });
    });
};
exports.setupSocketHandlers = setupSocketHandlers;


===== ./src/server.ts =====
import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import chatRoutes from './routes/chat';
import { setupSocketHandlers } from './socket/socketHandlers';

const app = express();
const server = http.createServer(app);
const io = new Server(server);

// Middleware
app.use(express.json());
app.use('/api/chat', chatRoutes);

// Socket.IO setup
setupSocketHandlers(io);

const PORT = process.env.PORT || 5001;

server.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});



===== ./src/middleware/auth.ts =====
import { Request, Response, NextFunction } from 'express';

const authMiddleware = (req: Request, res: Response, next: NextFunction) => {
    const token = req.headers['authorization'];

    if (!token) {
        return res.status(401).json({ message: 'Unauthorized' });
    }

    // Here you would typically verify the token and extract user information
    // For example, using a library like jsonwebtoken:
    // jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    //     if (err) {
    //         return res.status(403).json({ message: 'Forbidden' });
    //     }
    //     req.user = user;
    //     next();
    // });

    // For now, we'll just call next() to proceed
    next();
};

export default authMiddleware;

===== ./src/types/index.ts =====
// filepath: /chatroom-socketio/chatroom-socketio/server/src/types/index.ts
export interface Message {
    id: string;
    userId: string;
    content: string;
    timestamp: Date;
}

export interface User {
    id: string;
    username: string;
}

export interface ChatRoom {
    id: string;
    name: string;
    users: User[];
    messages: Message[];
}

===== ./src/models/Message.ts =====
import { Schema, model } from 'mongoose';

const messageSchema = new Schema({
  username: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
});

export const Message = model('Message', messageSchema);

===== ./src/controllers/chatController.ts =====
import { Request, Response } from 'express';
import { Message } from '../models/Message';

export const getMessages = async (req: Request, res: Response) => {
    try {
        const messages = await Message.find().sort({ createdAt: -1 });
        res.status(200).json(messages);
    } catch (error) {
        res.status(500).json({ message: 'Error retrieving messages' });
    }
};

export const sendMessage = async (req: Request, res: Response) => {
    const { username, content } = req.body;

    const newMessage = new Message({
        username,
        content,
        createdAt: new Date(),
    });

    try {
        const savedMessage = await newMessage.save();
        res.status(201).json(savedMessage);
    } catch (error) {
        res.status(500).json({ message: 'Error sending message' });
    }
};

===== ./src/routes/chat.ts =====
import { Router } from 'express';
import { getMessages, sendMessage } from '../controllers/chatController';

const router = Router();

// Route to get chat messages
router.get('/messages', getMessages);

// Route to send a new chat message
router.post('/messages', sendMessage);

export default router;

===== ./src/socket/socketHandlers.ts =====
import { Server } from "socket.io";
import { Message } from "../models/Message";

export const setupSocketHandlers = (io: Server) => {
  io.on("connection", (socket) => {
    console.log("A user connected:", socket.id);

    socket.on("joinRoom", (room) => {
      socket.join(room);
      console.log(`User ${socket.id} joined room: ${room}`);
    });

    socket.on("sendMessage", async (messageData) => {
      const message = new Message(messageData);
      await message.save();

      io.to(messageData.room).emit("message", message);
    });

    socket.on("disconnect", () => {
      console.log("User disconnected:", socket.id);
    });
  });
};

